/* 
  RuntimeShaders.strings
  Julia Set Renderer

  Created by Hezekiah Dombach on 1/27/21.
  Copyright Â© 2021 Hezekiah Dombach. All rights reserved.
*/





//MARK: Type.metal

#include <metal_stdlib>
using namespace metal;

enum Axis {x, y, z, na};

struct Plane {
	Axis axis;
	float value;
};

//MARK: RayMarcingSettings
struct RayMarchingSettings {
	float mandelbulbPower;
	int bundleSize;
	float quality;
	uint iterations;
	float bailout;
	float3 colorBase;
	float3 colorVariation;
	float3 colorFrequency;
	float3 colorOffset;
};

//MARK: Colors
struct Colors {
	float3 channel0;
	float3 channel1;
	float3 channel2;
	float3 channel3;
	float3 channel4;
	float3 channel5;
	float3 channel6;
	float3 channel7;
	
	float3 channel(int index) {
		switch (index) {
			case 0:
				return channel0;
			case 1:
				return channel1;
			case 2:
				return channel2;
			case 3:
				return channel3;
			case 4:
				return channel4;
			case 5:
				return channel5;
			case 6:
				return channel6;
			case 7:
				return channel7;
		}
	}
	
	void setChannel(int index, float3 newColor) {
		switch(index) {
			case 0:
				channel0 = newColor;
			case 1:
				channel1 = newColor;
			case 2:
				channel2 = newColor;
			case 3:
				channel3 = newColor;
			case 4:
				channel4 = newColor;
			case 5:
				channel5 = newColor;
			case 6:
				channel6 = newColor;
			case 7:
				channel7 = newColor;
		}
	}
	
	void changeChannel(int index, float3 offsetColor) {
		float3 oldColor = channel(index);
		setChannel(index, oldColor + offsetColor);
	}
	
	uint channels() {
		return 8;
	}
};

struct Channel {
	uint index;
	float3 color;
	float strength;
};

struct NodeFunctions {
	void add(thread float *out1, float in1, float in2) {
		*out1 = in1 + in2;
	}
	
	void multiply(thread float *out1, float in1, float in2) {
		*out1 = in1 * in2;
	}
	
	void divide(thread float *out1, float in1, float in2) {
		*out1 = in1 / in2;
	}
	
	void isGreater(thread float *out1, float in1, float in2) {
		*out1 = in1 > in2;
	}
	
	void combine(thread float *out1, thread float *out2, thread float *out3, float in1, float in2, float in3) {
		*out1 = in1;
		*out2 = in2;
		*out3 = in3;
	}
	
	void seperate(thread float *out1, thread float *out2, thread float *out3, float in1, float in2, float in3) {
		*out1 = in1;
		*out2 = in2;
		*out3 = in3;
	}
	
	void nodeClamp(thread float *out1, float value, float rangeMin, float rangeMax) {
		*out1 =  clamp(value, rangeMin, rangeMax);
	}
	
	void nodeSin(thread float *out1, float in) {
		*out1 = sin(in);
	}
	
	void nodeCos(thread float *out1, float in) {
		*out1 = cos(in);
	}
	
	void abs(thread float *out, float in) {
		*out = ::abs(in);
	}
	
	void vectorAdd(thread float *outX, thread float *outY, thread float *outZ, float in1x, float in1y, float in1z, float in2x, float in2y, float in2z) {
		*outX = in1x + in2x;
		*outY = in1y + in2y;
		*outZ = in1z + in2z;
	}
	
	void vectorLength(thread float *out, float inx, float iny, float inz) {
		*out = length(float3(inx, iny, inz));
	}
	
	void vectorScale(thread float *outx, thread float *outy, thread float *outz, float inx, float iny, float inz, float scale) {
		*outx = inx * scale;
		*outy = iny * scale;
		*outz = inz * scale;
	}
	
	void color(thread float *outx, thread float *outy, thread float *outz, float inx, float iny, float inz) {
		*outx = inx;
		*outy = iny;
		*outz = inz;
	}
	
	void colorBlend(thread float *outx, thread float *outy, thread float *outz, float factor, float in1x, float in1y, float in1z, float in2x, float in2y, float in2z) {
		float3 result = float3(in1x, in1y, in1z) * factor + float3(in2x, in2y, in2z) * (1 - factor);
		*outx = result.x;
		*outy = result.y;
		*outz = result.z;
	}
	
	void map(thread float *out, float in, float fromMin, float fromMax, float toMin, float toMax) {
		*out = (in - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;
	}
	
	void vectorMap(thread float *outx, thread float *outy, thread float *outz, float inx, float iny, float inz, float fromMin, float fromMax, float toMin, float toMax) {
		map(outx, inx, fromMin, fromMax, toMin, toMax);
		map(outy, iny, fromMin, fromMax, toMin, toMax);
		map(outz, inz, fromMin, fromMax, toMin, toMax);
	}
	
	//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
	
	void perlin(thread float *out, float x, float y, float z) {
		*out = cnoise(float4(x, y, z, 0));
	}
	void perlin3(thread float *out1, thread float *out2, thread float *out3, float x, float y, float z) {
		*out1 = cnoise(float4(x, y, z, 0));
		*out2 = cnoise(float4(10, x, y, z));
		*out3 = cnoise(float4(z, 20, x, y));
	}
	
	float4 permute(float4 x){return fmod(((x*34.0)+1.0)*x, 289.0);}
	float4 taylorInvSqrt(float4 r){return 1.79284291400159 - 0.85373472095314 * r;}
	float4 fade(float4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
	
	float cnoise(float4 P){
		float4 Pi0 = floor(P); // Integer part for indexing
		float4 Pi1 = Pi0 + 1.0; // Integer part + 1
		Pi0 = fmod(Pi0, 289.0);
		Pi1 = fmod(Pi1, 289.0);
		float4 Pf0 = fract(P); // Fractional part for interpolation
		float4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
		float4 ix = float4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		float4 iy = float4(Pi0.yy, Pi1.yy);
		float4 iz0 = float4(Pi0.zzzz);
		float4 iz1 = float4(Pi1.zzzz);
		float4 iw0 = float4(Pi0.wwww);
		float4 iw1 = float4(Pi1.wwww);
		
		float4 ixy = permute(permute(ix) + iy);
		float4 ixy0 = permute(ixy + iz0);
		float4 ixy1 = permute(ixy + iz1);
		float4 ixy00 = permute(ixy0 + iw0);
		float4 ixy01 = permute(ixy0 + iw1);
		float4 ixy10 = permute(ixy1 + iw0);
		float4 ixy11 = permute(ixy1 + iw1);
		
		float4 gx00 = ixy00 / 7.0;
		float4 gy00 = floor(gx00) / 7.0;
		float4 gz00 = floor(gy00) / 6.0;
		gx00 = fract(gx00) - 0.5;
		gy00 = fract(gy00) - 0.5;
		gz00 = fract(gz00) - 0.5;
		float4 gw00 = float4(0.75) - ::abs(gx00) - ::abs(gy00) - ::abs(gz00);
		float4 sw00 = step(gw00, float4(0.0));
		gx00 -= sw00 * (step(0.0, gx00) - 0.5);
		gy00 -= sw00 * (step(0.0, gy00) - 0.5);
		
		float4 gx01 = ixy01 / 7.0;
		float4 gy01 = floor(gx01) / 7.0;
		float4 gz01 = floor(gy01) / 6.0;
		gx01 = fract(gx01) - 0.5;
		gy01 = fract(gy01) - 0.5;
		gz01 = fract(gz01) - 0.5;
		float4 gw01 = float4(0.75) - ::abs(gx01) - ::abs(gy01) - ::abs(gz01);
		float4 sw01 = step(gw01, float4(0.0));
		gx01 -= sw01 * (step(0.0, gx01) - 0.5);
		gy01 -= sw01 * (step(0.0, gy01) - 0.5);
		
		float4 gx10 = ixy10 / 7.0;
		float4 gy10 = floor(gx10) / 7.0;
		float4 gz10 = floor(gy10) / 6.0;
		gx10 = fract(gx10) - 0.5;
		gy10 = fract(gy10) - 0.5;
		gz10 = fract(gz10) - 0.5;
		float4 gw10 = float4(0.75) - ::abs(gx10) - ::abs(gy10) - ::abs(gz10);
		float4 sw10 = step(gw10, float4(0.0));
		gx10 -= sw10 * (step(0.0, gx10) - 0.5);
		gy10 -= sw10 * (step(0.0, gy10) - 0.5);
		
		float4 gx11 = ixy11 / 7.0;
		float4 gy11 = floor(gx11) / 7.0;
		float4 gz11 = floor(gy11) / 6.0;
		gx11 = fract(gx11) - 0.5;
		gy11 = fract(gy11) - 0.5;
		gz11 = fract(gz11) - 0.5;
		float4 gw11 = float4(0.75) - ::abs(gx11) - ::abs(gy11) - ::abs(gz11);
		float4 sw11 = step(gw11, float4(0.0));
		gx11 -= sw11 * (step(0.0, gx11) - 0.5);
		gy11 -= sw11 * (step(0.0, gy11) - 0.5);
		
		float4 g0000 = float4(gx00.x,gy00.x,gz00.x,gw00.x);
		float4 g1000 = float4(gx00.y,gy00.y,gz00.y,gw00.y);
		float4 g0100 = float4(gx00.z,gy00.z,gz00.z,gw00.z);
		float4 g1100 = float4(gx00.w,gy00.w,gz00.w,gw00.w);
		float4 g0010 = float4(gx10.x,gy10.x,gz10.x,gw10.x);
		float4 g1010 = float4(gx10.y,gy10.y,gz10.y,gw10.y);
		float4 g0110 = float4(gx10.z,gy10.z,gz10.z,gw10.z);
		float4 g1110 = float4(gx10.w,gy10.w,gz10.w,gw10.w);
		float4 g0001 = float4(gx01.x,gy01.x,gz01.x,gw01.x);
		float4 g1001 = float4(gx01.y,gy01.y,gz01.y,gw01.y);
		float4 g0101 = float4(gx01.z,gy01.z,gz01.z,gw01.z);
		float4 g1101 = float4(gx01.w,gy01.w,gz01.w,gw01.w);
		float4 g0011 = float4(gx11.x,gy11.x,gz11.x,gw11.x);
		float4 g1011 = float4(gx11.y,gy11.y,gz11.y,gw11.y);
		float4 g0111 = float4(gx11.z,gy11.z,gz11.z,gw11.z);
		float4 g1111 = float4(gx11.w,gy11.w,gz11.w,gw11.w);
		
		float4 norm00 = taylorInvSqrt(float4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		g0000 *= norm00.x;
		g0100 *= norm00.y;
		g1000 *= norm00.z;
		g1100 *= norm00.w;
		
		float4 norm01 = taylorInvSqrt(float4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		g0001 *= norm01.x;
		g0101 *= norm01.y;
		g1001 *= norm01.z;
		g1101 *= norm01.w;
		
		float4 norm10 = taylorInvSqrt(float4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		g0010 *= norm10.x;
		g0110 *= norm10.y;
		g1010 *= norm10.z;
		g1110 *= norm10.w;
		
		float4 norm11 = taylorInvSqrt(float4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		g0011 *= norm11.x;
		g0111 *= norm11.y;
		g1011 *= norm11.z;
		g1111 *= norm11.w;
		
		float n0000 = dot(g0000, Pf0);
		float n1000 = dot(g1000, float4(Pf1.x, Pf0.yzw));
		float n0100 = dot(g0100, float4(Pf0.x, Pf1.y, Pf0.zw));
		float n1100 = dot(g1100, float4(Pf1.xy, Pf0.zw));
		float n0010 = dot(g0010, float4(Pf0.xy, Pf1.z, Pf0.w));
		float n1010 = dot(g1010, float4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		float n0110 = dot(g0110, float4(Pf0.x, Pf1.yz, Pf0.w));
		float n1110 = dot(g1110, float4(Pf1.xyz, Pf0.w));
		float n0001 = dot(g0001, float4(Pf0.xyz, Pf1.w));
		float n1001 = dot(g1001, float4(Pf1.x, Pf0.yz, Pf1.w));
		float n0101 = dot(g0101, float4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		float n1101 = dot(g1101, float4(Pf1.xy, Pf0.z, Pf1.w));
		float n0011 = dot(g0011, float4(Pf0.xy, Pf1.zw));
		float n1011 = dot(g1011, float4(Pf1.x, Pf0.y, Pf1.zw));
		float n0111 = dot(g0111, float4(Pf0.x, Pf1.yzw));
		float n1111 = dot(g1111, Pf1);
		
		float4 fade_xyzw = fade(Pf0);
		float4 n_0w = mix(float4(n0000, n1000, n0100, n1100), float4(n0001, n1001, n0101, n1101), fade_xyzw.w);
		float4 n_1w = mix(float4(n0010, n1010, n0110, n1110), float4(n0011, n1011, n0111, n1111), fade_xyzw.w);
		float4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		float2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
		float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		return 2.2 * n_xyzw;
	}

};


//MARK: Material
struct Material {
	float3 rgbAbsorption, rgbEmitted;
	float diffuse;
	
	float rand(int x, int y, int z)
	{
		int seed = x + y * 57 + z * 241;
		seed= (seed<< 13) ^ seed;
		return (( 1.0 - ( (seed * (seed * seed * 15731 + 789221) + 1376312589) & 2147483647) / 1073741824.0f) + 1.0f) / 2.0f;
	}
	
	float3 sin(float3 value) {
		return float3(metal::precise::sin(value.x), metal::precise::sin(value.y), metal::precise::sin(value.z));
	}
	
	void init(float3 position, float3 orbit, float iterations, RayMarchingSettings settings, constant float *constants) {
		NodeFunctions functions;
		
		float empty;
		
		//INSERT_MATERIAL//
		
		//rgbAbsorption = float3(rand(position.x * 2.1, position.y * 2.31, position.z * 2.1), rand(position.x * 2.1, position.y * 3.1, position.z * 5.23), rand(position.x * 2.21, position.y * 1.24, position.z * 2.09));
		if (rand(x * 12059812, y * 98213, z * 5091283) > 0.5) {
			diffuse = 0.1;
		} else {
			diffuse = 0.9;
		}
		float distanceFromCenter = distance(position, float3(0, 0, 0));
		
		rgbAbsorption = clamp(settings.colorBase + settings.colorVariation * sin(distanceFromCenter * settings.colorFrequency + settings.colorOffset), float3(0), float3(1));
		//rgbAbsorption = float3(0.4 + 0.4 * metal::precise::sin(distanceFromCenter * 100), 0.4 + 0.4 * metal::precise::cos(distanceFromCenter * 40), 0.4 + 0.4 * metal::precise::cos(distanceFromCenter * 30));//(10 + 5 * sin(distanceFromCenter * 30));
	}
};

//MARK: Ray
struct Ray {
	float4 position;
	float4 deriction;
	
	float3 colorAbsorption;
	Colors colors;
	
	void normalize() {
		deriction = metal::normalize(deriction);
	};
	
	void march(float distance) {
		position += deriction * distance;
	}
};

//MARK: SkyBoxLight
struct SkyBoxLight {
	float3 color;
	float strength;
	float size;
	float3 position;
	uint channel;
	uint id;
	
	float3 getColor(Ray ray) {
		if (size < dot(normalize(ray.deriction.xyz), normalize(position))) {
			return color * strength;
		}
		return float3(0);
	}
};

//MARK: Camera
struct Camera {
	float4 position;
	float4 deriction;
	float zoom;
	float depth;
	float4x4 rotateMatrix;
	float2 resolution;
	
	//text coord is from -1 to 1
	Ray spawnRay(float2 texCoord) {
		float4 rayDeriction = normalize(float4((texCoord.x - 0.5) * resolution.x * zoom, (texCoord.y - 0.5) * resolution.y * zoom, 1, 1));
		rayDeriction *= rotateMatrix;
		Ray ray;
		ray.deriction = normalize(rayDeriction);
		ray.position = position;
		ray.colorAbsorption = float3(1, 1, 1);
		for (int c = 0; 8 > c; c++) {
			ray.colors.setChannel(c, float3(0, 0, 0));
		}
		return ray;
	}
};

//MARK: ShaderInfo
struct ShaderInfo {
	RayMarchingSettings rayMarchingSettings;
	Camera camera;
	uint4 realIndex;
	uint3 randomSeed;
	uint voxelsLength;
	uint isJulia;
	uint lightsLength;
	uint exposure;
	uint channelsLength;
};

struct VoxelInfo {
	float3 position;
	float size;
	uint index;
};

struct CollisionInfo {
	float3 position;
	float3 surfaceNormal;
	Material surfaceMaterial;
};

struct DistanceInfo {
	float distance;
	Axis collisionAxis;
};

//Int allows numbers from 0 to 4294967295(2^32)
//MARK: Voxel
struct VoxelAddress {
	uint index;
	bool isDefault() {
		return (index == 0);
	}
};

struct Voxel {
	float opacity;
	bool isEnd;
	float3 position;
	uint layer;
	
	float width() {
		return pow(0.5, float(layer)) * 1;
	}
	
	VoxelAddress _p;
	VoxelAddress _0;
	VoxelAddress _1;
	VoxelAddress _2;
	VoxelAddress _3;
	VoxelAddress _4;
	VoxelAddress _5;
	VoxelAddress _6;
	VoxelAddress _7;
	
	//uint children[8];
	
	VoxelAddress child(int number) {
		switch(number) {
			case 0:
				return _0;
			case 1:
				return _1;
			case 2:
				return _2;
			case 3:
				return _3;
			case 4:
				return _4;
			case 5:
				return _5;
			case 6:
				return _6;
			case 7:
				return _7;
			default:
				return _p;
		}
	}
	
	void setChild(int number, VoxelAddress newAddress) {
		switch(number) {
			case 0:
				_0 = newAddress;
			case 1:
				_1 = newAddress;
			case 2:
				_2 = newAddress;
			case 3:
				_3 = newAddress;
			case 4:
				_4 = newAddress;
			case 5:
				_5 = newAddress;
			case 6:
				_6 = newAddress;
			case 7:
				_7 = newAddress;
			default:
				_p = newAddress;
		}
	}
	
	void setChildIndex(int number, int newIndex) {
		switch(number) {
			case 0:
				_0.index = newIndex;
			case 1:
				_1.index = newIndex;
			case 2:
				_2.index = newIndex;
			case 3:
				_3.index = newIndex;
			case 4:
				_4.index = newIndex;
			case 5:
				_5.index = newIndex;
			case 6:
				_6.index = newIndex;
			case 7:
				_7.index = newIndex;
			default:
				_p.index = newIndex;
		}
	}
	
	VoxelAddress getChild(bool3 position) {
		uint index = 0;
		if (position.x) {
			index += 1;
		}
		if (position.y) {
			index += 2;
		}
		if (position.z) {
			index += 4;
		}
		
		return child(index);
	}
	
	VoxelAddress getChildRay(float4 rayPosition) {
		bool3 newChild;
		float selfWidth = width();
		newChild.x = (rayPosition.x > position.x + selfWidth);
		newChild.y = (rayPosition.y > position.y + selfWidth);
		newChild.z = (rayPosition.z > position.z + selfWidth);
		

		return getChild(newChild);
	}
};



























//MARK: MatchContainer.metal
struct MathContainer {
	// Generate a random float in the range [0.0f, 1.0f] using x, y, and z (based on the xor128 algorithm)
	float rand(int x, int y, int z) {
		int seed = x + y * 57 + z * 241;
		seed= (seed<< 13) ^ seed;
		return (( 1.0 - ( (seed * (seed * seed * 15731 + 789221) + 1376312589) & 2147483647) / 1073741824.0f) + 1.0f) / 2.0f;
	}
	
	/*float2 getAngle(float3 normal) {
		float2 angle;
		angle.x = atan(normal.y / normal.z);
		float distance = sqrt(normal.y * normal.y + normal.z * normal.z);
		angle.y = atan(normal.x / distance);
		
		return angle;
	}*/
	
	float3 getNormal(float2 angle) {
		
		float3x3 xRotation = float3x3 {
			float3(1, 0, 0),
			float3(0, cos(angle.x), -sin(angle.x)),
			float3(0, sin(angle.x), cos(angle.x))
		};
		
		float3x3 yRotation = float3x3 {
			float3(cos(angle.y), 0, sin(angle.y)),
			float3(0, 1, 0),
			float3(-sin(angle.y), 0, cos(angle.y))
		};
		
		return xRotation * yRotation * float3(0, 0, 1);
	}
	
	DistanceInfo distanceToPlane(Ray ray, Plane plane) {
		if (plane.axis == x) {
			float xDistance = (plane.value - ray.position.x) / ray.deriction.x;
			if (xDistance > 0) {
				return {xDistance, x};
			} else {
				return {FLT_MAX, x};
			}
		} else if (plane.axis == y) {
			float yDistance =  (plane.value - ray.position.y) / ray.deriction.y;
			if (yDistance > 0) {
				return {yDistance, y};
			} else {
				return {FLT_MAX, y};
			}
		} else if (plane.axis == z) {
			float zDistance = (plane.value - ray.position.z) / ray.deriction.z;
			if (zDistance > 0) {
				return {zDistance, z};
			} else {
				return {FLT_MAX, z};
			}
		}
		return {FLT_MAX, na};
	}
	
	float4 intersectionOnPlane(Ray ray, Plane plane) {
		return ray.position + distanceToPlane(ray, plane).distance * ray.deriction;
	}
	
	//this function assumes the ray is already inside a voxel
	DistanceInfo distanceToVoxel(Ray ray, device Voxel *voxel) {
		Voxel newVoxel = *voxel;
		float3 planes;
		if (ray.deriction.x > 0) {
			planes.x = newVoxel.position.x + newVoxel.width();
		} else {
			planes.x = newVoxel.position.x;
		}
		if (ray.deriction.y > 0) {
			planes.y = newVoxel.position.y + newVoxel.width();
		} else {
			planes.y = newVoxel.position.y;
		}
		if (ray.deriction.z > 0) {
			planes.z = newVoxel.position.z + newVoxel.width();
		} else {
			planes.z = newVoxel.position.z;
		}
		
		DistanceInfo lengthX = distanceToPlane(ray, {x, planes.x});
		DistanceInfo lengthY = distanceToPlane(ray, {y, planes.y});
		DistanceInfo lengthZ = distanceToPlane(ray, {z, planes.z});
		
		if (lengthX.distance < lengthY.distance && lengthX.distance < lengthZ.distance) {
			return lengthX;
		} else if (lengthY.distance < lengthZ.distance) {
			return lengthY;
		} else {
			return lengthZ;
		}
	}
	
	//this function assumes ray is outside the voxel/cube
	DistanceInfo distanceToCube(Ray ray, device Voxel *voxel) {
		Voxel cube = *voxel;
		float3 planes;
		if (ray.deriction.x > 0) {
			planes.x = cube.position.x;
		} else {
			planes.x = cube.position.x + cube.width();
		}
		if (ray.deriction.y > 0) {
			planes.y = cube.position.y;
		} else {
			planes.y = cube.position.y + cube.width();
		}
		if (ray.deriction.z > 0) {
			planes.z = cube.position.z;
		} else {
			planes.z = cube.position.z + cube.width();
		}
		
		float3 intersectionX = intersectionOnPlane(ray, {x, planes.x}).xyz;
		float3 intersectionY = intersectionOnPlane(ray, {y, planes.y}).xyz;
		float3 intersectionZ = intersectionOnPlane(ray, {z, planes.z}).xyz;
		
		if (intersectionX.y > cube.position.y && intersectionX.y < cube.position.y + cube.width() && intersectionX.z > cube.position.z && intersectionX.z < cube.position.z + cube.width()) {
			return distanceToPlane(ray, {x, planes.x});
		}
		if (intersectionY.x > cube.position.x && intersectionY.x < cube.position.x + cube.width() && intersectionY.z > cube.position.z && intersectionY.z < cube.position.z + cube.width()) {
			return distanceToPlane(ray, {y, planes.y});
		}
		if (intersectionZ.x > cube.position.x && intersectionZ.x < cube.position.x + cube.width() && intersectionZ.y > cube.position.y && intersectionZ.y < cube.position.y + cube.width()) {
			return distanceToPlane(ray, {z, planes.z});
		}
		return {FLT_MAX, na};
	}
};

					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
//MARK: RayMarching.metal

struct RayMarchInfo {
	float d;
	float orbitLife;
	float3 orbit;
};

struct RayMarching {
	bool cubeContainsRay(Ray ray, device Voxel *voxel) {
		Voxel cube = *voxel;
		if (ray.position.x > cube.position.x && ray.position.x < cube.position.x + cube.width()) {
			if (ray.position.y > cube.position.y && ray.position.y < cube.position.y + cube.width()) {
				if (ray.position.z > cube.position.z && ray.position.z < cube.position.z + cube.width()) {
					return true;
				}
			}
		}
		return false;
	}
	
	
	float3 getNormal(Axis axis) {
		switch (axis) {
			case x:
				return float3(1, 0, 0);
			case y:
				return float3(0, 1, 0);
			case z:
				return float3(0, 0, 1);
			case na:
				return float3(0, 0, 0);
		}
	}
	
	
	VoxelAddress getVoxelChild2(bool3 position, device Voxel *voxel) {
		uint index = 0;
		if (position.x) {
			index += 1;
		}
		if (position.y) {
			index += 2;
		}
		if (position.z) {
			index += 4;
		}
		
		Voxel v = *voxel;
		return v.child(index);
	}
	VoxelAddress getVoxelChildAtRay(float4 rayPosition, device Voxel *voxel) {
		bool3 newChild;
		Voxel newVoxel = *voxel;
		float width = newVoxel.width() / 2;
		newChild.x = (rayPosition.x > newVoxel.position.x + width);
		newChild.y = (rayPosition.y > newVoxel.position.y + width);
		newChild.z = (rayPosition.z > newVoxel.position.z + width);
		
		return getVoxelChild2(newChild, voxel);
	}
	
	device Voxel * getVoxel(VoxelAddress voxelAddress, device Voxel *voxels, int voxelsLength) {
		// VoxelContainer container;
		return &voxels[voxelAddress.index];
	}
	
	device Voxel * getVoxel(Ray atRay, device Voxel *voxels, int voxelsLength) {
		device Voxel *currentVoxel = &voxels[1];
		
		while (!currentVoxel->isEnd) {
			VoxelAddress newAddress = getVoxelChildAtRay(atRay.position, currentVoxel);
			if (newAddress.isDefault()) {
				return currentVoxel;
			}
			currentVoxel = getVoxel(newAddress, voxels, voxelsLength);
		}
		
		return currentVoxel;
	}
	
	DistanceInfo getVoxelRayStep(Ray ray, device Voxel *voxels, int voxelsLength) {
		MathContainer maths;
		return maths.distanceToVoxel(ray, getVoxel(ray, voxels, voxelsLength));
	}
	
	RayMarchInfo newBulbDE(float3 pos, RayMarchingSettings settings) {
		float3 z = pos;
		float dr = 1;
		float r = 0;
		float power = settings.mandelbulbPower;
		uint iterations = settings.iterations;
		RayMarchInfo info;
		info.orbitLife = iterations;
		for (int i = 0; i < iterations; i++) {
			r = length(z);
			if (r > settings.bailout) {
				info.orbitLife = i;
				break;
			}
			
			//convert to polar
			float theta = acos(z.z / r);
			float phi = atan(z.y / z.x);
			dr = pow(r, power - 1) * power * dr + 1;
			
			//scale and rotate the point
			float zr = pow(r, power);
			theta = theta * power;
			phi = phi * power;
			
			//convert back to cartesian
			z = zr * float3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
			z += pos;
		}
		info.d = 0.5 * log(r) * r / dr;
		info.orbit = z;
		return info;
	}
	
	float3 mirror(float3 p, float3 normal) {
		return p - 2 * fmin(0, dot(p, normal)) * normal;
	}
	
	float TriangleDE(float3 z, RayMarchingSettings settings)
	{
		float Scale = 2;
		float Offset = 1;
		int n = 0;
		while (n < settings.iterations) {
			if(z.x+z.y<0) z.xy = -z.yx; // fold 1
			if(z.x+z.z<0) z.xz = -z.zx; // fold 2
			if(z.y+z.z<0) z.zy = -z.yz; // fold 3
			z = z*Scale - Offset*(Scale-1.0);
			n++;
		}
		return (length(z) ) * pow(Scale, -float(n));
	}
	
	RayMarchInfo SphereDE(float3 pos, float r, RayMarchingSettings settings) {
		RayMarchInfo info;
		float3 c = float3(0.5, 0.5, 0.5);
		info.d = length(pos - c) - r;
		//info.d = max(length(fmod(pos, float(1)) - c) - r, length(pos - c) - 10);
		info.orbitLife = settings.iterations;
		return info;
	}
	
	RayMarchInfo DE(float3 pos, RayMarchingSettings settings) {
		//RayMarchInfo info;
		//info.orbitLife = settings.iterations;
		//info.d = TriangleDE(mirror(pos, float3(0, 1, 0)), settings);
		return newBulbDE(pos, settings);
	}
	
	float3 DEnormal(float3 pos, RayMarchingSettings settings) {
		//e is an abitrary number
		//e can cause white specks to appear if chosen wrongly
		float e = 0.0001;
		float n = DE(pos, settings).d;
		float dx = DE(pos + float3(e, 0, 0), settings).d - n;
		float dy = DE(pos + float3(0, e, 0), settings).d - n;
		float dz = DE(pos + float3(0, 0, e), settings).d - n;
		
		return normalize(float3(dx, dy, dz) * -1);
	}
};
























//MARK: Rendering.metal

//Contains functions that are usefl
struct RayTracer {
	struct VectorPair {
		float3 v1;
		float3 v2;
	};
	
	VectorPair orthogonalVectors(float3 n) {
		float3 axis;
		if (abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z)) {
			axis = float3(1.0, 0.0, 0.0);
		} else if (abs(n.y) < abs(n.z)) {
			axis = float3(0.0, 1.0, 0.0);
		} else {
			axis = float3(0.0, 0.0, 1.0);
		}
		
		VectorPair result;
		result.v1 = normalize(cross(n, axis));
		result.v2 = normalize(cross(n, result.v1));
		
		return result;
	}
	
	float3 sampleUniformHemisphere(float3 n, int3 randomSeed) {
		MathContainer math;
		float3 p;
		int3 seed = randomSeed;
		//randomly creates point on a hemisphere (not tilted)
		do {
			p.z = math.rand(seed.x, seed.y, seed.z);
			p.x = math.rand(seed.y, seed.z, seed.x) * 2 - 1;
			p.y = math.rand(seed.z, seed.x, seed.y) * 2 - 1;
			seed += int3(512, 723, 152);
		} while (p.x * p.x + p.y * p.y + p.z * p.z > 1);
		
		p = normalize(p);
		
		//Transform random vector so it fits on hemisphere of the normal
		VectorPair orthogonals = orthogonalVectors(n);
		
		p = p.x * orthogonals.v1 + p.y * orthogonals.v2 + p.z * n;
		return p;
	}
	
	float3 sampleUniformHemisphere2(float3 n, int3 randomSeed) {
		MathContainer math;
		float2 p;
		int3 seed = randomSeed;
		do {
			p.x = math.rand(seed.x, seed.y, seed.z) * 2 - 1;
			p.y = math.rand(seed.y, seed.z, seed.x) * 2 - 1;
			seed += int3(512, 723, 152);
		} while (p.x * p.x + p.y * p.y > 1);
		
		return projectToHemisphere(p, n);
	}
	
	float3 mapToHemisphere(float2 p, float3 normal) {
		float d = length(p);
		float shift = 1 - (1 - d) * (1 - d);
		p = p / d * shift;
		float z = sqrt(1 - shift * shift);
		
		VectorPair orthogonals = orthogonalVectors(normal);
		
		return orthogonals.v1 * p.x + orthogonals.v2 * p.y + normal * z;
	}
	
	float3 projectToHemisphere(float2 p, float3 normal) {
		float d = length(p);
		float z = sqrt(1 - d * d);
		
		VectorPair orthogonals = orthogonalVectors(normal);
		
		return orthogonals.v1 * p.x + orthogonals.v2 * p.y + normal * z;
	}
	
	float3 correctNormal(float3 normal, float3 vector) {
		if (dot(normal, vector) < 0) {
			return normal;
		} else {
			return normal * -1;
		}
	}

	float errorDifference = 0.00001;

	struct SingleResult {
		Ray ray;
		float distance;
		CollisionInfo collision;
        int steps;
	};

	//MARK: Skybox
	Colors getSkyBox(Ray ray, constant SkyBoxLight *lights, int lightsLength) {
		Colors color;
		for (uint c = 0; 8 > c; c++) {
			
			color.setChannel(c, float3(0, 0, 0));
		}
		
		for (int c = 0; lightsLength > c; c++) {
			SkyBoxLight light = lights[c];
			
			color.setChannel(light.channel, light.getColor(ray));
		}
		
		return color;
	}

	Ray reflect(Ray ray, float3 surfaceNormal, Material surfaceMaterial, uint3 _seed) {
		MathContainer math;

		Ray returnRay = ray;
		for (int c = 0; 8 > c; c++) {
			
			returnRay.colors.changeChannel(c, ray.colorAbsorption * surfaceMaterial.rgbEmitted);
		}
		returnRay.colorAbsorption *= surfaceMaterial.rgbAbsorption;

		int3 seed = int3(0, 0, 0);
		if (false) { //set false for more random bounces
			seed.x = round(returnRay.position.x * 1030);
			seed.y = round(returnRay.position.y * 1241);
			seed.z = round(returnRay.position.z * 1518);
		} else {

			seed.x = (returnRay.position.x * 1033594);
			seed.y = (returnRay.position.y * 1243421);
			seed.z = (returnRay.position.z * 1516648);
		}
		seed *= int3(_seed);
		
		returnRay.deriction.xyz = sampleUniformHemisphere(surfaceNormal, seed);
		returnRay.deriction.xyz = metal::reflect(returnRay.deriction.xyz, surfaceNormal);
		returnRay.deriction.w = 1;
		return returnRay;
	}
	
	//Function not being used right now
	float rideRay(Ray primaryRay, Ray secondaryRay, RayMarchingSettings settings) {
		RayMarching rayMarcher;
		//float tempDot = dot(normalize(primaryRay.deriction.xyz), normalize(secondaryRay.deriction.xyz));
		//float k = sqrt(1 - tempDot * tempDot) / tempDot;
		float k = length(normalize(secondaryRay.deriction.xyz) - normalize(primaryRay.deriction.xyz));
		float rLast = 0;
		float r = 0;
		float t = 0;
		
		while (100000 > t) {
			rLast = r;
			r = rayMarcher.DE(primaryRay.position.xyz + t * normalize(primaryRay.deriction.xyz), settings).d;
			float thing = 0.5 * r * r / rLast;
			float tSphereIntersection = t - thing;
			float rSphereIntersection = sqrt(r * r - thing);
			if (rSphereIntersection < k * tSphereIntersection || t / settings.quality > r) {
				return t;
			}
			t += r;
		}
		return t;
	}
    
	//Single bounce using raytracing
    SingleResult mandelBulb(Ray rayIn, uint3 seed, float fog, RayMarchingSettings settings, constant float *constants) {
		RayMarching rayMarcher;
		
        Ray ray = rayIn;
		
        int steps = 0;
        DistanceInfo d = {0, na};
		RayMarchInfo bulbResut;
        while (100000 > d.distance) {
            bulbResut = rayMarcher.DE(ray.position.xyz, settings);
            float step = bulbResut.d;
            ray.march(step);
            /*float3 offset;
            offset.x = maths.rand(seed.x * uint(ray.position.y * 451245), seed.y, seed.z);
            offset.y = maths.rand(seed.y * uint(ray.position.x * 5019823), seed.z, seed.x);
            offset.z = maths.rand(seed.z * uint(ray.position.z * 502814), seed.x, seed.y);
            ray.position += float4(fog * offset.x * step, fog * offset.y * step, fog * offset.z * step, 0);*/
            d.distance += step;
            steps ++;
            if (1 * d.distance / settings.quality > step || 500 < steps) {
				if (steps > 500 && false) {
					ray.march(100000);
					d.distance += 100000;
				}
                break;
            }
        }
		ray.march(errorDifference * -1);
        //ray.march(-1 * errorDifference);
        SingleResult result;
        result.distance = d.distance;
        result.steps = steps;
        result.collision.surfaceNormal = rayMarcher.DEnormal(ray.position.xyz, settings);
		result.collision.surfaceNormal = correctNormal(result.collision.surfaceNormal, ray.deriction.xyz);
        
        Material material;
        material.init(ray.position.xyz, bulbResut.orbit, bulbResut.orbitLife, settings, constants);
        
        result.collision.surfaceMaterial = material;
        result.collision.position = ray.position.xyz;
        //result.collision.orbitPosition = bulbResut.orbitPosition;
        result.ray = ray;
        return result;
    }

	//single bounce using raytracing function
	SingleResult shootRay(Ray rayIn, device Voxel *voxels, bool showVoxels, int voxelsLength, RayMarchingSettings settings, constant float *constants) {
		MathContainer math;
		RayMarching rayMarcher;
		
		Ray ray = rayIn;

		device Voxel *rootVoxel = &voxels[1];

		DistanceInfo distance = {0, na};
        int steps = 0;
		while (10000 > distance.distance) {
			DistanceInfo step = {0, na};
			if (rayMarcher.cubeContainsRay(ray, rootVoxel)) {
				device Voxel *intersectedVoxel = rayMarcher.getVoxel(ray, voxels, voxelsLength);
				if (intersectedVoxel->opacity > 0.5) {
					ray.march(errorDifference * -2);
					break;
				}
				if (showVoxels) {
					ray.colorAbsorption *= float3(0.9);
				}
				step = math.distanceToVoxel(ray, intersectedVoxel);
			} else {
				step = math.distanceToCube(ray, rootVoxel);
			}
			step.distance += errorDifference;
			ray.march(step.distance);
			distance.distance += step.distance;
			distance.collisionAxis = step.collisionAxis;
            steps++;
		}

		Material material;
		material.init(ray.position.xyz, float3(0), 0, settings, constants);

		CollisionInfo collide;
		collide.position = float3(ray.position.x, ray.position.y, ray.position.z);
		collide.surfaceMaterial = material;
		collide.surfaceNormal = rayMarcher.getNormal(distance.collisionAxis);
		collide.surfaceNormal = correctNormal(collide.surfaceNormal, ray.deriction.xyz);


		SingleResult result;
		result.distance = distance.distance;
		result.ray = ray;
		result.collision = collide;
        result.steps = steps * 10;

		return result;
	}
    
    void bundle(texture2d_array<float, access::read> readTexture [[texture(0)]],
                texture2d_array<float, access::write> writeTexture [[texture(1)]],
                uint index [[ thread_position_in_grid ]],
                constant uint &groupSize [[buffer(5)]]) {
        
    }

	//main raycasating function
	Colors rayCast(float2 pos, int bounceLimit, device Voxel *voxels, bool showVoxels, constant SkyBoxLight *lights, float2 textureSize, ShaderInfo info, constant float *constants) {
		MathContainer math;
		
		float skip = 0;
		if (info.isJulia == 1 && info.rayMarchingSettings.bundleSize > 1) {
			Ray primary = info.camera.spawnRay(pos + float2(0.5 / textureSize.x, 0.5 / textureSize.y));
			Ray secondary = info.camera.spawnRay(pos);
			skip = rideRay(primary, secondary, info.rayMarchingSettings);
		}
		
		uint3 seed2 = info.randomSeed;
		
		//for (int c = 0; info.rayMarchingSettings.bundleSize > c; c++) {
			seed2 += uint3(5129,312,5021);
			float2 randomOffset;
			if (info.rayMarchingSettings.bundleSize > 0) {
				randomOffset.x = math.rand(seed2.x, pos.x * 983414, seed2.z * 33429);
				randomOffset.y = math.rand(seed2.y, pos.y * 754239, seed2.z * 46523);
			} else {
				randomOffset = float2(0);
			}
			
			float2 newPos = pos + randomOffset / textureSize;
			Ray ray = info.camera.spawnRay(newPos);
			ray.march(skip);
			
			int bounces = 0;
			while (bounces < bounceLimit) {
				SingleResult result;
				if (info.isJulia == 0) {
					result = shootRay(ray, voxels, showVoxels, info.voxelsLength, info.rayMarchingSettings, constants);
				} else {
					result = mandelBulb(ray, info.randomSeed, 0.01, info.rayMarchingSettings, constants);
				}
				//return float4(result.collision.surfaceNormal, 1);
				ray = result.ray;
				if (result.distance >= 100000) {
					if (bounces > 0) {
						Colors colors = getSkyBox(ray, lights, info.lightsLength);
						for (int c = 0; 8 > c; c++) {
							float3 oldColor = colors.channel(c);
							ray.colors.setChannel(c, oldColor * ray.colorAbsorption);
							//ray.colors.changeChannel(c, ray.colorAbsorption * colors.channel(c));
						}
					}
					break;
				}
				ray.colorAbsorption = ray.colorAbsorption * (1 - result.distance / 10);
				
				ray = reflect(ray, result.collision.surfaceNormal, result.collision.surfaceMaterial, info.randomSeed);
				bounces ++;
			}
		//}
		//return getSkyBox(ray, lights, info.lightsLength);
		return ray.colors;
	}
	
	float4 depthMap(float2 pos, Camera camera, device Voxel *voxels, int voxelsLength, int isJulia, constant SkyBoxLight *lights, int lightsLength, RayMarchingSettings settings, ShaderInfo info, constant float *constants) {
		Ray ray = camera.spawnRay(pos);
		float3 originalDirection = normalize(ray.deriction.xyz);
		
		SingleResult result;
		if (isJulia == 0) {
			result = shootRay(ray, voxels, false, voxelsLength, settings, constants);
		} else {
			result = mandelBulb(ray, uint3(0, 0, 0), 0, settings, constants);
			/*if (result.distance < 10000) {
				ray.march(result.distance);
				//return float4(bulb.normal(ray.position.xyz), 0);
			}*/
		}
		
		//return float4(result.collision.surfaceNormal, 1);
		
		//float4 color = float4(log(result.distance)) + 0.2;
		float4 color = float4(log(result.distance + 1) / 5 - 0.05);
		return color;
	}

	float4 preview(float2 pos, Camera camera, device Voxel *voxels, int voxelsLength, int isJulia, constant SkyBoxLight *lights, int lightsLength, RayMarchingSettings settings, ShaderInfo info, constant float *constants) {
		Ray ray = camera.spawnRay(pos);
		float3 originalDirection = normalize(ray.deriction.xyz);
		
        SingleResult result;
        if (isJulia == 0) {
            result = shootRay(ray, voxels, false, voxelsLength, settings, constants);
        } else {
            result = mandelBulb(ray, uint3(0, 0, 0), 0, settings, constants);
            if (result.distance < 10000) {
                ray.march(result.distance);
                //return float4(bulb.normal(ray.position.xyz), 0);
            }
        }
		
		//return float4(result.collision.surfaceNormal, 1);

		//float4 color = float4(log(result.distance)) + 0.2;
        float4 color = float4(1, 1, 1, 1) * float4(result.collision.surfaceMaterial.rgbAbsorption, 0);
        color *= pow(0.995, float(result.steps));
		color *= abs(dot(normalize(originalDirection), normalize(result.collision.surfaceNormal)));
		if (result.distance > 100) {
			float3 tempColor = float3(0);
			Colors colors = getSkyBox(ray, lights, lightsLength);
			for (uint c = 0; c < info.channelsLength; c++) {
				tempColor += colors.channel(c);
			}
			color = float4(tempColor, 1);
			return color;
		}
		//color = 1 - (color - 0.2) / color;
		return color;
	}
};























//MARK: Shaders.metal

struct VertexIn {
	float3 position [[ attribute(0) ]];
	float4 color [[ attribute(1) ]];
	float2 texCoord [[ attribute(2) ]];
};

struct RasterizerData {
	float4 position [[ position ]];
	float4 color;
	float2 texCoord;
};
vertex RasterizerData basic_vertex_shader(const VertexIn vIn [[ stage_in ]],
										  constant float &viewRatio [[ buffer(1) ]],
										  constant float &imageRatio [[ buffer(2) ]]) {
	RasterizerData rd;
	if (imageRatio < viewRatio) {
		rd.position = float4(vIn.position.x * imageRatio / viewRatio, vIn.position.y, vIn.position.z, 1);
	} else {
		rd.position = float4(vIn.position.x, vIn.position.y / imageRatio * viewRatio, vIn.position.z, 1);
	}
	//rd.position = float4(vIn.position.x / 2, vIn.position.y / 2, 0, 1);
	rd.color = vIn.color;
	rd.texCoord = vIn.texCoord;

	return rd;
}

fragment float4 basic_fragment_shader(RasterizerData rd [[ stage_in ]],
									  sampler sampler2d [[ sampler(0) ]],
									  texture2d_array<float> texture [[ texture(0) ]],
									  constant ShaderInfo &info [[buffer(0)]],
									  constant Channel *channels [[buffer(3)]]) {
	float4 color = float4(0);
	for (uint c = 0; info.channelsLength > c; c++) {
		float3 channelColor;
		Channel channel = channels[c];
		channelColor.r = texture.sample(sampler2d, rd.texCoord, 0 + c * 3).x * channel.color.r;
		channelColor.g = texture.sample(sampler2d, rd.texCoord, 1 + c * 3).x * channel.color.g;
		channelColor.b = texture.sample(sampler2d, rd.texCoord, 2 + c * 3).x * channel.color.b;
		
		channelColor *= channel.strength;
		
		color.r += channelColor.r;
		color.g += channelColor.g;
		color.b += channelColor.b;
	}
	color.a = 1;

	return color / info.exposure;
}



fragment float4 depth_fragment_shader(RasterizerData rd [[ stage_in ]],
									  constant ShaderInfo &shaderInfo [[buffer(0)]],
									  device Voxel *voxels [[buffer(1)]],
									  constant SkyBoxLight *lights [[buffer(2)]],
									  constant float *constants [[buffer(4)]]) {
	RayTracer yeet;
	ShaderInfo info = shaderInfo;
	return float4(yeet.depthMap(rd.texCoord, info.camera, voxels, info.voxelsLength, info.isJulia, lights, info.lightsLength, info.rayMarchingSettings, info, constants));
	//return float4(yeet.rayCast(rd.texCoord, myCamera, 4, voxels));
}

fragment float4 preview_fragment_shader(RasterizerData rd [[ stage_in ]],
									  constant ShaderInfo &shaderInfo [[buffer(0)]],
									  device Voxel *voxels [[buffer(1)]],
									  constant SkyBoxLight *lights [[buffer(2)]],
									  constant float *constants [[buffer(4)]]) {
	RayTracer yeet;
	ShaderInfo info = shaderInfo;
	return float4(yeet.preview(rd.texCoord, info.camera, voxels, info.voxelsLength, info.isJulia, lights, info.lightsLength, info.rayMarchingSettings, info, constants));
	//return float4(yeet.rayCast(rd.texCoord, myCamera, 4, voxels));
}

fragment float4 sample_fragment_shader(RasterizerData rd [[ stage_in ]],
									   constant ShaderInfo &shaderInfo [[buffer(0)]],
									   device Voxel *voxels [[buffer(1)]],
									   constant SkyBoxLight *lights [[buffer(2)]],
									   constant float *constants [[buffer(4)]]) {
	//MathContainer maths;
	RayTracer rayShooter;

	ShaderInfo info = shaderInfo;
	info.rayMarchingSettings.bundleSize = 0;

	return float4(rayShooter.rayCast(rd.texCoord, 2, voxels, false, lights, float2(0), info, constants).channel(0), 1);
}

kernel void ray_compute_shader(texture2d_array<float, access::read> readTexture [[texture(0)]],
							   texture2d_array<float, access::write> writeTexture [[texture(1)]],
							   uint index [[ thread_position_in_grid ]],
							   constant ShaderInfo &shaderInfo [[buffer(0)]],
							   device Voxel *voxels [[buffer(1)]],
							   constant SkyBoxLight *lights [[buffer(2)]],
							   constant float *constants [[buffer(4)]]) {
	RayTracer rayShooter;
	MathContainer math;
	
	ShaderInfo info = shaderInfo;

	float anIndex = info.realIndex.x + index;

	if (anIndex > info.realIndex.w) {
		return;
	}
	anIndex = fmod(anIndex, info.realIndex.y * info.realIndex.z);

	float2 pos;
	pos.x = floor(fmod(anIndex, float(info.realIndex.y * info.realIndex.z)) / float(info.realIndex.z));
	pos.y = fmod(anIndex, float(info.realIndex.z));
	uint2 textureIndex = uint2(pos.x, pos.y);

    uint3 seed = info.randomSeed;
    seed.x += index * 402;
    seed.y += index * 503;
    seed.z += index * 305;
    
    
	float2 randomOffset;
	randomOffset.x = math.rand(info.randomSeed.x, pos.x * 983414, anIndex * 33429);
	randomOffset.y = math.rand(info.randomSeed.y, pos.y * 754239, anIndex * 46523);

	pos.x = (pos.x + 0) / readTexture.get_width();
	pos.y = (pos.y + 0) / readTexture.get_height();
	/*int a;
	for( a = 0; a < 10; a++ ){
		color += rayShooter.rayCast(pos, myCamera, 10, voxels, randomSeed);
	}
	color = color / 10;*/
	Colors colors = rayShooter.rayCast(pos, 4, voxels, false, lights, float2(readTexture.get_width(), readTexture.get_height()), info, constants);
	//float4 color = float4(pos.x + 0.00001, pos.y + 0.0000001, 0.5, 1) * 100;
	for (uint c = 0; info.channelsLength > c; c++) {
		float3 oldColor;
		oldColor.x = readTexture.read(textureIndex, 3 * c).x;
		oldColor.y = readTexture.read(textureIndex, 3 * c + 1).x;
		oldColor.z = readTexture.read(textureIndex, 3 * c + 2).x;
		
		float3 color = colors.channel(c);
		writeTexture.write(float4(oldColor.x + color.x, 0, 0, 0), textureIndex, 3 * c);
		writeTexture.write(float4(oldColor.y + color.y, 0, 0, 0), textureIndex, 3 * c + 1);
		writeTexture.write(float4(oldColor.z + color.z, 0, 0, 0), textureIndex, 3 * c + 2);
	}
	//writeTexture.write(color + oldColor, textureIndex);
	//writeTexture.write(float4(randomOffset.x, randomOffset.y, 0, 1), textureIndex);
	return;
}

kernel void reset_compute_shader(texture2d_array<float, access::write> writeTexture [[texture(0)]],
											uint2 index [[ thread_position_in_grid]],
											constant ShaderInfo &info [[buffer(0)]]) {
	for (int c = 0; c < info.channelsLength * 3; c++) {
		writeTexture.write(float4(0, 0, 0, 0), index, c);
	}
	return;
}
